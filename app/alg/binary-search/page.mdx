# 二分查找 binary search

**「二分查找 binary search」** 是一种高效的搜索算法，基于分治思想（Divide and Conquer），专门用于在有序数组中查找目标元素。它每一步缩小一半搜索范围，直至找到目标元素或搜索区间为空。

相比于线性查找的 $O(n)$ 时间复杂度，二分查找能将查找效率提升到 $O(\log n)$。

## 算法步骤

1. **初始化搜索区间**：设定左边界 l 和右边界 r，分别指向数组的首尾。
2. **循环搜索**：在搜索区间内，每次取中点 _`m`_，比较中点值与目标值，根据结果收缩区间。
3. **终止条件**：找到目标元素或区间为空时，结束循环。

## 经典问题

### 问题 1：查找目标值的索引

在一个升序数组中查找目标值 _`target`_ ，如果找到，返回其索引，否则返回 _`-1`_ 。

_`func indexOf(nums []int, target int) int`_

<Tree>
#### !left
1. [初始化搜索边界 _`l`_ 和 _`r`_ 为数组的第一个和最后一个元素坐标](!focus#6) 。 
2. 循环搜索：
  - [计算中点 _`m`_](!focus#8)，判断中点值 _go`nums[m]`_ 与 _`target`_ 的关系
		- [相等：返回索引](!focus#9:10)
		- [小于：收缩左边界](!focus#11:12)
		- [大于：收缩右边界](!focus#13:14)
	- [循环条件：_go`l <= r`_，当 _go`l == r + 1`_ 时，搜索区间为空，结束循环](!focus#7,15)。
3. [循环结束仍未找到目标值，返回 _`-1`_](!focus#17)

#### !right
```go !!codes !lines(5:18) binary-search.go
!from ./binary-search.go 5:18
```

</Tree>

### 问题 2： 查找第一个满足条件的元素

在 $[0,n)$ 内，找到第一个满足条件的整数，如果都不满足，则返回 _`n`_ 。

_`func binarySearch(n int, f func(int) bool) int`_

这个问题应用非常广泛，比如：

- _`indexOf(nums []int, target int) int`_

  ```go
  func indexOf(nums []int, target int) int {
      k := binarySearch(len(nums), func(i int) bool { return nums[i] >= target })
      if k == target || nums[k] != target {
          return -1
      }
      return k
  }
  ```

- 查找某元素的插入位置：在一个有序数组中，找到第一个大于等于目标值的元素。

  ```go
  binarySearch(len(nums), func(i int) bool {
    return nums[i] >= target
  })
  ```

- <div className="text-red-400">
    @todo ...
  </div>

两种区间定义：

- **「左闭右闭」** $[l, r]$
- **「左闭右开」** $[l, r)$

#### 左闭右闭

<Tree>
##### !left
- 区间变量的定义：
  - [_`l`_: 当前搜索区间中 **「可能满足条件的最小索引」**。](!focus#22)
  - [_`r`_: 当前搜索区间中 **「可能不满足条件的最大索引」**](!focus#22)。
- 有了这两个变量的准确定义，我们就可以比较容易的确定算法实现的具体细节：
- 收缩搜索区间：
  - [中点 _`m`_ 满足条件时，目标值是 _`m`_ 或在 _`m`_ 左侧，收缩右侧边界， _`r`_ 更新为「可能不满足条件的最大索引」](!focus#25:26)。
  - [当中点 _`m`_ 不满足条件时，目标值在 _`m`_ 右侧， _`l`_ 更新为「满足条件的可能最小索引」](!focus#25,27:28)。
- [循环终止条件：_go`l <= r`_， 当 _go`l == r + 1`_ 时， _`l`_ 和 _`r`_ 变量定义中的“可能” 转变成了 “确定”，结束搜索。](!focus#23,30)
  - _`l`_ 变成了 **「满足条件的最小索引」**
  - _`r`_ 变成了 **「不满足条件的最大索引」**
- [_`l`_ 现在是 「满足条件的最小索引」，所以返回值为 _`l`_](!focus#31)。

##### !right
```go !!codes !lines(20:32) binary-search.go
!from ./binary-search.go 20:32
```

</Tree>

#### 左闭右开

<Tree>
##### !left

- 区间变量的定义：
  - [_`l`_: 当前搜索区间中 **「可能满足条件的最小索引」**](!focus#36)。
  - [_`r`_: 当前搜索区间中 **「已确定满足条件的最小索引」**，因为如果 $[1,n)$ 中都不满足，则返回 _`n`_, 所以这里假设 _`n`_ 为最小的满足条件的索引](!focus#36)。
- 算法实现的具体细节：
- 收缩搜索区间：
  - [中点 _`m`_ 满足条件时，目标值是 _`m`_ 或在 _`m`_ 左侧，收缩右侧边界， 当前已经确定满足条件的最小索引是 _`m`_，更新 _`r`_](!focus#39:40)。
  - [当中点 _`m`_ 不满足条件时，目标值在 _`m`_ 右侧，更新 _`l`_ 为「满足条件的可能最小索引」](!focus#39,41:42)。
- [循环终止条件：_go`l < r`_， 当 _go`l == r`_ 时， _`l`_ 和 _`r`_ 定义中的“可能” 转变成了 “确定”，结束搜索。](!focus#37,44)
  - _`l`_ 变成了 **「满足条件的最小索引」**
  - _`r`_ 也变成了 **「满足条件的最小索引」**
- [_`l`_ 现在是 「满足条件的最小索引」，所以返回值为 _`l`_](!focus#45)。

##### !right 
```go !!codes !lines(34:46) binary-search.go
!from ./binary-search.go 34:46
```

</Tree>
