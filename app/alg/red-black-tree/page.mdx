# 红黑树 Red Black Tree

红黑树（Red-Black Tree）是一种自平衡二叉查找树（BST），它在插入和删除节点时通过重新着色和旋转操作来保持树的平衡，从而确保在最坏的情况下基本的动态集合操作（如插入、删除、查找等）时间复杂度为 $O(\lg n)$。

本篇分析了黑树的 Go 语言实现，旨在帮助读者能熟悉红黑树的性质并独立实现红黑树。

## 1. 左倾红黑树的主要特点

_rbt_insert|红黑树示例|s`a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z`_

> 红黑树模型中结点通过红链（红色链接）连接到父结点，用来模拟 2-3平衡查找树 中的 3-结点，而在代码实现中我们将子结点的 _`color`_ 属性标记为红色。所以，下文中 红/黑结点 和 红/黑链接的表述都是同一个意思。

> 二叉查找树 下文中会简称为 二叉树。

>  红黑树的黑色链接高度定义为「任意空链接到根结点的简单路径上的黑链接数量」。

> 左倾红黑树有下面一些特点， 其中一些是为了简化代码实现和定义所作的规定。为了保证红黑树结构有效，对红黑树进行操作时，我们必须保持 '❗️' 标记的 3 点性质。

<Accordion className="h-[750px]">

### !!steps 二叉树 ❗️
红黑树是一棵二叉查找树，满足一切二叉查找树性质。

[可以方便的实现如 有序集合、有序字典 等数据结构，并在 $O(\lg n)$ 的时间内完成如（插入、删除、查找等）操作](!focus#50,81)。

右侧代码:
- [红黑树根据键查找值的实现与二叉树查找完全一致。](!focus#50,61)
- [红黑树插入键值的实现和二叉树相比，插入后的递归回溯阶段多一步平衡操作。](!focus#68,80:81)


```go  !!codes !lines(49:62,67:82)  red_black_tree.go 
!from ./red_black_tree.go 49:82
```

```go !!codes !lines(64:73,74:81) red_black_tree_test.go
!from ./red_black_tree_test.go 64:81
```
### !!steps 红黑结点

[每个节点要么是红色，要么是黑色。](!focus#4:5,15,19)

[和二叉树相比，红黑树结点结构中多一个 _go`color bool`_ 字段，标记结点当前颜色。](!focus#8,11)


```go !!codes  !lines(2:21) red_black_tree.go
!from ./red_black_tree.go 2:21
```
### !!steps 左倾
为了方便代码实现，我们规定「红链接均为左链接」，即[平衡操作完成后红色结点均为左子结点。](!focus#199,205)

一个 3-结点里，额外的 key 是在左边还是右边，其实是对称的。 所以用红链接表示 3-结点时，会有 两种等价表示：
- 父红 + 左黑（红在左）
- 父黑 + 右红（红在右）

如果不加约束，树的表示就不唯一，代码维护也很麻烦。
约定左倾后，每个 3-结点只有左倾这一种表示方式，插入删除时只需要处理固定的几种情况，可以大幅简化代码实现。

```go !!codes !lines(197:211) red_black_tree.go
!from ./red_black_tree.go 197:211
```

### !!steps 黑根
[规定根节点是黑色。](!focus#65,94:96)

允许根为红并不会破环红黑树的平衡性，但会让性质的定义和代码实现更复杂，如:
- 黑结点高度规定为「任意空链接到根结点的简单路径上的黑链接数量」，这保证了任一黑高路径至少有一半是黑结点。
- 操作结束后，最后一步会强制将根结点改成黑。[删除时判断是否需要将根结点标红的逻辑会更简单。](!focus#90:92)

```go !!codes !lines(62:67,82:100) red_black_tree.go
!from ./red_black_tree.go 62:100
```
### !!steps 黑叶子
所有的叶子节点（ NIL 节点）都是黑色的。 红黑树将二叉树的叶子结点的 NIL 子结点视为叶子结点，并约定颜色为黑色。

和黑根的约定类似，不将 NIL 结点视为叶子结点并不会破坏红黑树，但会让黑色结点高度定义和代码实现更复杂, 如：
- [平衡操作中需要判断 _go`x.left.left.isRed()`_, _go`x.right.left.isRed()`_](!focus#202)，如果没有黑叶子约定，需要先判断是否空结点，再对应实现逻辑。
- 删除操作中也有 _go`x.left.left.isRed()`_, _go`x.right.left.isRed()`_ 条件判断。


```go !!codes !lines(14:21,196:211) red_black_tree.go
!from ./red_black_tree.go 14:211
```

### !!steps 完美黑平衡 ❗️
[任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。](!focus#92:97,100:105)

这条性质决定了一棵大小为 $N$ 的红黑树的高度不会超过 $2\lg N$。
简单证明下：
- 左倾红黑树最坏的情况是构成树根到最左边叶子结点的路径是红黑相间的，而树根到最右边叶子结点的路径全是黑的。最右侧结点数量上界 $\lg N$，所以左边路径结点数量上界 $2\lg N$，完成证明。

```go !!codes !lines(63:73,87:110) red_black_tree_test.go
!from ./red_black_tree_test.go 63:110
```
### !!steps 无连续红结点 ❗️
[如果一个节点是红色的，那么它的子节点必须是黑色的（即不能有两个连续的红色节点）。](!focus#69,81,85) 红色结点不连续，才能保证「完美黑高平衡」 是有意义的，从而保证各种操作的时间复杂度都能制在 $O(\lg n)$。

红黑树可以理解为用 红黑结点组成的二叉树 模拟实现 「2-3平衡查找树」 ，将红结点和它的父结点共同组成 3-结点。若出现连续的两个红结点，则出现了4-结点，2-3树 不允许这种情况出现。

```go !!codes !lines(63:73,81:86) red_black_tree_test.go
!from ./red_black_tree_test.go 63:86
```

</Accordion>

综上，只要满足 「二叉树」、「完美黑平衡」 和 「无连续红结点」 三个条件，就是一棵红黑树，我们就能在 $O(lg N)$ 时间复杂度完成有序符号表/字典的各种操作。 而 「红黑结点」、「左倾」、「黑根」 和 「黑叶子」 等条件是我们为了简化红黑树实现的一些约定。

## 2. 红黑树的平衡操作可以控制红色的转移

二叉查找树的基础的平衡操作有 「左旋」，「右旋」 和 「颜色翻转」。
通过这三种平衡操作，我们可以在**不破环二叉树**，**不破环红黑树的平衡**的前提下，操作着**红色结点的向着我们预期的方向转移**。

### 2.1 颜色翻转

<Accordion className="h-[500px]">

#### !!steps 红色向上传递
当左右子结点都是红色，且父结点是黑色时，我们执行翻转可以将红色子结点转移到父结点上。也就时将红色向上（树根方向）传递。

<div>
_rbt_level|翻转后`p,o,null,l|red,r|red`_
_rbt_level|翻转前`p,o|red,null,l,r`_
</div>

```go !!codes !lines(169:174) red_black_tree.go
!from ./red_black_tree.go 169:174
```
#### !!steps 红色向下传递

反过来，当子结点都是黑色，且父结点时红色时，我们执行翻转会将红色链接丛父结点转移到子结点上，也就是将红色向下传递。
<div>
_rbt_level|翻转前`p,o|red,null,l,r`_
_rbt_level|翻转后`p,o,null,l|red,r|red`_
</div>

```go !!codes !lines(169:174) red_black_tree.go
!from ./red_black_tree.go 169:174
```

#### !!steps 可能破坏「无连续红结点」

翻转操作可能导致连续红色结点出现，需要及时修正。
</Accordion>

### 2.2 旋转

下面图示是向左旋转和向右旋转，本文中简称 「左旋」 和 「右旋」，

_rbt_level|左旋`o,l,r|red,null,null,rl,rr:rotateLeft(o):r,o|red,rr,l,rl`_
<span className="w-20 inline-block"/> _rbt_level|右旋`o,l|red,r,ll,lr,null:rotateRight(o):l,ll,o|red,null,null,lr,r`_

<Accordion className="h-[700px]">

### !!steps 旋转不会破环二叉查找树
[红黑树的左旋和右旋的实现，在其他平衡二叉树左右旋转的基础上，再加上颜色的转移。](!focus#154,163)

旋转前后键的大小关系不变：
- 左旋前后键值大小关系保持 _go`o < rl < r`_
  - 旋转前 _`o.r -> r, r.l -> rl`_
  - [旋转后 _`r.l -> o, o.r -> rl`_](!focus#153)
- 右旋前后键值大小关系保持  _go`l < lr < o`_
  - 旋转前 _`l.r -> lr, o.l -> l`_
  - [旋转后 _go`l.r -> o, o.l -> lr`_](!focus#162)


```go !!codes !lines(151:167) red_black_tree.go
!from ./red_black_tree.go 151:167
```
### !!steps 旋转不会破环「完美黑平衡」

旋转改变了左右子树高度，但旋转前后左右黑色链接高度没变，红黑树仍是完美平衡的。

### !!steps 旋转不会破环「无连续红色」

### !!steps 旋转将红色向左右转移
左旋会将右结点的红色转移到左侧。
1. [左旋前的右结点 _`r`_ 是红色](!focus#199)
2. [右结点 _`r`_ 替代 _`o`_ 成为了新的中间结点](!focus#156,200)
3. [_`o`_ 成为了 _`r`_ 的左子结点，并标记为红色](!focus#153:154)，转换后新子树的左子结点变成了红色

同样，[右旋会将左结点的红色转移到右侧。](!focus#162:163,165,202:203)

但是，旋转操纵红色结点的左右的转移只是相对于红黑树来说的，旋转前后红色链接仍在父结点同一个子结点之间，并不能红链接转移到父结点和另一个字节上面。

```go !!codes !lines(151:167,197:210) red_black_tree.go
!from ./red_black_tree.go 151:210
```

</Accordion>


## 3. 红黑树插入的实现

在了解了 「左旋」，「右旋」 和 「颜色翻转」 之后，接下来，我们来思考下如何实现红黑树的插入的代码。

<Tree className="max-h-[700px]">

### !left
为了让代码更简洁，我们选择以递归方式往 [二叉树中插入结点](!focus#63:64,66,68:79,81) 。此时，红黑树 「无连续红结点」 和 「完美黑平衡」 两点性质可能被破环。如果我们能保持这两点，插入操作完成后我们得到的仍是一棵红黑树。

所以我们下面讨论如何保持着两点性质：

完美黑平衡
    - 找到插入位置之后，我们 [插入一个红色的新结点](!focus#70:72)，这不影响「完美黑平衡」。
    - 后续的所有操作，我们都只使用之前讨论过的 「翻转颜色」、「左旋」 和「右旋」，也不影响 「完美黑平衡」。

连续红结点
    - 新插入红色结点，导致了红黑树中可能出现连续红结点。 
    我们考虑在[递归调用 _go`put(key, val)`_ 方法的回溯阶段](!focus#68,80:81)，对可能出现了的连续红结点进行修复。因为递归程序的回溯阶段和修复连续红结点天然契合：
      1. 回溯阶段是在插入结点这个动作之后
      2. 可以逆着查找路径向上尝试修复（插入结点 -> 父亲 -> ... -> root）。如果我们将红色结点向上传递，就是这条路径
    - “插入了红结点后，或者子结点向父结点传递和红色结点”都会让某个子结点变成了红色，接下来我们枚举各种情况：
      1. [黑结点右侧变成了红结点](!focus@2#0): 执行「左旋」， 保证左倾
      2. [黑结点左侧变成了红结点](!focus@2#1)：不需要调整
      3. [红结点的父结点右侧变成了红结点](!focus@2#2)：执行「翻转颜色」，将红结点向父结点传递。
      4. [红结点的左侧变成了红结点](!focus@2#3)： 执行「右旋」，消除了左侧红结点。这时候[变成了 3 的状态](!focus@2#2,3)。
      5. [红结点的右侧变成了红结点](!focus@2#4)：执行「左旋」保持左倾，这时候[变成了 4 的状态](!focus@2#3,4)。
    - 分析上面 5 种情况我们可以总结出执行顺序：
      - 对于状态 5 和 1 ，执行 「左旋」
      - 然后，对于状态 4，执行 「右旋」
      - 最后对于状态 3，执行 「翻转颜色」
    - 现在，我们可以确定：[在递归的回溯过程中，沿着父结点向上依次尝试进行 「左旋」 「右旋」 「翻转颜色」 3 步操作之后，我们可以修复连续红结点的问题。](!focus#80,197:210)
      1. [左旋 保持红黑树是左倾的](!focus@1#0)。
      2. [右旋 修复左侧红结点连续](!focus@1#1)。
      3. [翻转颜色 将红色向上传递](!focus@1#2)。

最后，我们遵循 「黑根」 的约定，[将根结点置为黑色](!focus#65)。

### !right

```go !!codes !lines(63:81,196:210) red_black_tree.go
!from ./red_black_tree.go 63:210
```

#### !!contents 平衡操作
_rbt_level|1.左旋`o,l,r|red,null,null,rl,rr:rotateLeft(o):r,o|red,rr,l,rl`_

_rbt_level|2.右旋`o,l|red,r,ll|red,lr:rotateRight(o):l,ll|red,o|red,null,null,lr,r`_

_rbt_level|3.颜色翻转`o,l|red,r|red,ll:flipColor(o):o|red,l,r,ll`_

#### !!contents 枚举需要修复的红色结点

_rbt_level|1.黑结点右侧变红!left|s`5::5,null,7|red:rotateLeft(5):7,5|red`_

_rbt_level|2.黑结点左侧变红!left|s`5::5,3|red`_

_rbt_level|3.红结点的父结点右侧变红!left|s`4,3|red::4,3|red,5|red:flipColor(4):4|red,3,5`_

_rbt_level|4.红结点左侧变红!left|s`5,4|red::5,4|red,null,3|red:rotateRight(5):4,3|red,5|red`_

_rbt_level|5.红结点右侧变红!left|s`5,3|red::5,3|red,null,null,4|red:rotateLeft(4):5,4|red,null,3|red`_

</Tree>

## 4. 红黑树的删除的实现


查找删除元素的过程肯定和二叉树一样，沿着父子关系自上而下查找，找到待删除结点，然后我们考虑删除操作对红黑树的影响：
  - 如果是一个叶子结点，和新插入的是红色结点的思路一样，如果这是一个红色结点，这样就可以直接删除而不会影响黑平衡。这时候我们会想到，可以尝试从父亲（翻转）或者兄弟结点借（旋转），但我们却不能保证有红色结点可以借用。所以，如果需要的话，我们将根结点标红，然后沿着搜索路径向下传递直到到达待删除的叶子结点，然后删除。删除结点后，然后逆向沿着查找路径修复「右倾」和「连续红结点」的问题。
  - 如果是一个中间结点，用它右子树的最小结点和它交换，然后删除右侧最小结点。这时候又变成了删除一个叶子结点的问题。同时，我们不会破环这个中间结点的状态，也就不需要考虑这个中间结点是否红色。


### 4.1 删除最小元素 

<Tree>

_go`delMin()`_ 会一直沿着左链接到达最左边叶子结点的父元素，然后将红色的左子元素删掉。比 _go`delete(key)`_ 实现简单很多，却能够很好的体现红黑树删除时的思路，我们先拿它热身。

### !left


为了保证不会破环「二叉树」这条规则，我们[在二叉树的 _go`delMin()`_](!focus#130:134,138:140)的基础上进行讨论。为了不破坏「完美黑平衡」，被删除元素必须是红色。先给个结论再论证：我们要求「沿着左链接向下的过程中，[左子结点和左孙结点中有且只有一个是红色](!focus#138)」。满足了这点，我们就能保证能够成功删除最小元素，因为：
- 若左子和左孙结点都是红色，则破坏了「无连续红结点」规则。
- 一定有红色元素可以向下传递。如果孙结点是红色，不需要传递，否则，子结点可以把自己的红色传递给孙结点。
- 待删除元素一定会是红结点：因为我们有「黑叶子」的约定，当左子结点是待删除元素时，左孙结点 是 _go`nil`_，被看作是黑结点，所以 此时左子结点是红结点，可以被删除。

如何实现 「左子结点和左孙结点中有且只有一个是红色」？
答案是如果需要的话从上向下传递红色。但是，翻转颜色向下传递红色结点，这可能会破环 「无连续红色结点」 的规则。
1. [右子结点的左子结点是黑色，无需额外修复](!focus@1#0)，[回溯阶段调用 _`x.balance()`_ 可以修复右倾的问题](!focus#139)。
2. [若右子结点的左子结点是红色时，翻转颜色之后，右子结点变成红色，产生了连续红色结点，我们可以通过右旋+左旋+翻转修复图示。](!focus@1#1)。

以上讨论了[沿左侧向下传递红色，或者说是将当前结点的红色传递给了左子结点，也就是图示中结点 5 的红色传递给了结点 3](!focus@1#0,1) 。这个过程在 _go`delete(key)`_ 中需要复用，所以将上述过程[封装成 _go`moveRedLeft`_](!focus#175:184)。

[增加了 _go`x = x.moveRedLeft()`_ 之后](!focus#135:137)，叉树的删除最小元素逻辑可以顺利进行了。

### !right

```go !!codes !lines(130:141,175:185) red_black_tree.go
!from ./red_black_tree.go 130:185
```

#### !!contents moveRedLeft()

_rbt_level|1.右侧红结点不连续!left|s`5|red,3,7,2,null,6:flipColor(5):5,3|red,7|red,2,null,6`_

_rbt_level|2.修复右侧红结点连续!left|s`5|red,3,7,2,null,6|red:flipColor(5):5,3|red,7|red,2,null,6|red:rotateRight(7):5,3|red,6|red,2,null,null,7|red:rotateLeft(5):6,5|red,7|red,3|red,null,null,null,2:flipColor(6):6|red,5,7,3|red,null,null,null,2`_


</Tree>

### 4.2 moveRightLeft

<Tree className="max-h-[560px] min-h-[560px]">
#### !left
同 `delMin()` 中的讨论，我们只能删除红色叶子结点。当我们沿着右侧链接向下移动时，也需要保证右侧有红色结点可借用。也就是需要满足「右子结点和右子结点的左子结点中有且只有一个是红色」。

同样为了保证这点，我们[实现了 _`moveRedRight()`_](!focus#116:118,186:194)，[如图示，_`node5.rotateRight()`_ 将 _`node5`_ 的红色传递给了  _`node7`_](!focus@1#0,1)

#### !right

```go !!codes !lines(101:128,186:194) red_black_tree.go
!from ./red_black_tree.go 101:194
```
##### !!contents moveRedRight()

_rbt_level|左侧红结点不连续!left|s`5|red,3,7,1,null,6:flipColor(5):5,3|red,7|red,1,null,6`_

_rbt_level|修复左侧红结点连续!left|s`5|red,3,7,1|red,null,6::5,3|red,7|red,1|red,null,6:rotateRight(5):3,1|red,5|red,null,null,null,7|red,6:flipColor(3):3|red,1,5,null,null,null,7|red,6`_

</Tree>


### 4.3 红黑树的删除

在树根处准备好红色结点，自上而下沿着搜索路径传递红色，执行完删除操作后，再在回溯阶段修复红黑树。

<Tree className="max-h-[900px]">

#### !left

为了简化实现，我们[用递归方式实现删除](!focus#93,101,108,122,124,127)。
删除操作也是[在二叉树删除的基础上进行](!focus#103,108:109,119:128)，整个删除过程中不破环「二叉树」的性质。

基于之前的讨论，我们只能删除红色叶子结点，所以在沿着查找路径向下的过程中，我们需要保证：
- [沿着左侧路径向下时，保证「左子结点和左孙结点有且只有一个是红色」](!focus#105:107)
- [沿着右侧路径向下时，保证「右子结点和右子结点的左子结点有且只有一个是红色」](!focus#116:118)

两种情况其实是一样，当我们要沿着搜索路径到达某一点前，要先确保「这个点和它的左子结点有且只有一个是红色」。

为了保证初始状态满足上述两点，[根结点或其左子结点必须有红色结点](!focus#90:92)。这就是向下传递的红色结点的来源。

如果树中不包含待删除元素，让需要沿着查找路径向下传递红色，然后在回溯阶段修复。相对于这些复杂操作，我们选择[先确定红黑树是否包含此元素](!focus#84:87)再执行删除。

[沿左侧路径向下递归删除](!focus#103:109)和 _`delMin()`_ 的实现一致。

沿右侧路径向下要求右子结点和右子结点的左子结点有且只有一个是红色，首先要保证父结点是红色，才能传递给右结点，父结点的红色有两个来源：
- 从左侧兄弟结点传递而来。这种情况下沿右侧向下时，[首先要做的是将左子结点的红色右旋传递到父结点上](!focus#109:112)。这样父结点才有红色结点可以传递给右结点。
- 沿着查找路径从父结点的父结点传递来的，在[查找路径的上一个结点已经完成](!focus#116:118) 

在确保当前结点是红色的前提下，如果当前结点的右结点是空，由红黑树的黑平衡可知其左结点也是空，所以这是一个二叉树叶子结点，直接[删除当前二叉树叶子结点](!focus#113:115)。

我们看完了沿右侧下降递归删除的逻辑，下面整理一下顺序：
1. [尝试从左子结点借来红色](!focus#110:112)，这样做保证了当前结点是红色。
2. 确保了当前结点是红色之后，如果右结点是空，则是[二叉树叶子结点，可以删除](!focus#113:115)。
3. 接下来我们意图向右侧移动搜索，如果需要的话[将当前结点的红色传给右子结点](!focus#116:118)。
4. 同二叉树删除，如果待删除结点是中间结点，[和右侧最小结点交换，然后删除右侧最小元素](!focus#119:123)
5. 执行二叉树递归删除，继续[沿右侧链接删除结点](!focus#103,109,119,123:125)
#### !right

```go !!codes !lines(83:128) red_black_tree.go
!from ./red_black_tree.go 83:128
```

</Tree>
