# 红黑树 Red Black Tree

红黑树（Red-Black Tree）是一种自平衡二叉查找树（BST），它在插入和删除节点时通过重新着色和旋转操作来保持树的平衡，从而确保在最坏的情况下基本的动态集合操作（如插入、删除、查找等）时间复杂度为 $O(\lg n)$。

本篇分析了黑树的 Go 语言实现，旨在帮助读者能熟悉红黑树的性质并独立实现红黑树。

## 左倾红黑树的主要特点：


红黑树模型中结点通过红链（红色链接）连接到父结点，用来模拟 2-3平衡查找树 中的 3-结点，而在代码实现中我们将子结点的 _`color`_ 属性标记为红色。所以，红/黑结点 和 红/黑链接的表述都是同一个意思。

红黑树的黑色链接高度定义为「任意空链接到根结点的简单路径上的黑链接数量」。
左倾红黑树有下面一些特点， 其中一些是为了简化代码实现和定义所作的规定，我们对红黑树构建的必要条件做了 '❗️' 标记。

<Accordion className="h-[750px]">

### !!steps 二叉树 ❗️
红黑树是一棵二叉查找树，满足一切二叉查找树性质。

[可以方便的实现如 有序集合、有序字典 等数据结构，并在 $O(\lg n)$ 的时间内完成如（插入、删除、查找等）操作](!focus#50:61,68:79,81)。


右侧代码:
- [_go`get`_ 是红黑树根据键查找值的实现，与二叉树查找完全一致。](!focus#50:61)
- [_go`put`_ 是红黑树插入键值的实现，和二叉树相比，插入值后，多一步平衡操作 _`x.balance()`_。](!focus#68:79,81)


```go  !!codes !lines(49:62,67:82)  red_black_tree.go 
!from ./red_black_tree.go 49:82
```

```go !!codes !lines(64:73,74:81) red_black_tree_test.go
!from ./red_black_tree_test.go 64:81
```
### !!steps 红黑结点 ❗️

[每个节点要么是红色，要么是黑色。](!focus#4:5,15,19)

[和二叉树相比，红黑树结点结构中多一个 _go`color bool`_ 字段，标记结点当前颜色。](!focus#8,11)


```go !!codes  !lines(2:21) red_black_tree.go
!from ./red_black_tree.go 2:21
```

### !!steps 无连续红结点 ❗️
[如果一个节点是红色的，那么它的子节点必须是黑色的（即不能有两个连续的红色节点）。](!focus#69,81,85)

红黑树可以理解为用 红黑结点组成的二叉树 模拟实现 「2-3平衡查找树」 ，将红结点和它的父结点共同组成 3-结点。若出现连续的两个红结点，则出现了4-结点，2-3树 不允许这种情况出现。

```go !!codes !lines(63:73,81:86) red_black_tree_test.go
!from ./red_black_tree_test.go 63:86
```
### !!steps 黑根
[规定根节点是黑色。](!focus#65,94:96)

允许根为红并不会破环红黑树的平衡性，但会让性质的定义和代码实现更复杂，如:
- 黑结点高度规定为「任意空链接到根结点的简单路径上的黑链接数量」，这保证了任一黑高路径至少有一半是黑结点。
- 操作结束后，最后一步会强制将根结点改成黑。[删除时判断是否需要将根结点标红的逻辑会更简单。](!focus#90:92)

```go !!codes !lines(62:67,82:100) red_black_tree.go
!from ./red_black_tree.go 62:100
```
### !!steps 黑叶子（NIL）
所有的叶子节点（ NIL 节点）都是黑色的。 红黑树将二叉树的叶子结点的 NIL 子结点视为叶子结点，并约定颜色为黑色。

和黑根的约定类似，不将 NIL 结点视为叶子结点并不会破坏红黑树，但会让黑色结点高度定义和代码实现更复杂, 如：
- [平衡操作中需要判断 _go`x.left.left.isRed()`_, _go`x.right.left.isRed()`_](!focus#202)，如果没有黑叶子约定，需要先判断是否空结点，再对应实现逻辑。
- 删除操作中也有 _go`x.left.left.isRed()`_, _go`x.right.left.isRed()`_ 条件判断。


```go !!codes !lines(14:21,196:211) red_black_tree.go
!from ./red_black_tree.go 14:211
```

### !!steps 完美黑平衡 ❗️
[任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。](!focus#92:97,100:105)

这条性质决定了一棵大小为 $N$ 的红黑树的高度不会超过 $2\lg N$。

```go !!codes !lines(63:73,87:110) red_black_tree_test.go
!from ./red_black_tree_test.go 63:110
```


### !!steps 左倾
为了方便代码实现，我们规定「红链接均为左链接」，即[平衡操作完成后红色结点均为左子结点。](!focus#199,205)

一个 3-结点里，额外的 key 是在左边还是右边，其实是对称的。 所以用红链接表示 3-结点时，会有 两种等价表示：
- 父红 + 左黑（红在左）
- 父黑 + 右红（红在右）

如果不加约束，树的表示就不唯一，代码维护也很麻烦。
约定左倾后，每个 3-结点只有左倾这一种表示方式，插入删除时只需要处理固定的几种情况，可以大幅简化代码实现。

```go !!codes !lines(197:211) red_black_tree.go
!from ./red_black_tree.go 197:211
```

</Accordion>

## 红黑树的平衡操作

二叉查找树的平衡操作都是由「左旋」和「右旋」来实现的。
红黑树中旋转的方向的选择取决于颜色。

<Accordion>

### !!steps 旋转不会破环二叉查找树
旋转前后键的大小关系不变 

左旋前后键值大小关系保持 _go`o < rl < r`_
- 旋转前 _`o.r -> r, r.l -> rl`_
- [旋转后 _`r.l -> o, o.r -> rl`_](!focus#153)

右旋前后键值大小关系保持  _go`l < lr < o`_
- 旋转前 _`l.r -> lr, o.l -> l`_
- [旋转后 _go`l.r -> o, o.l -> lr`_](!focus#163)

```go !!codes !lines(151:167) red_black_tree.go
!from ./red_black_tree.go 151:167
```



### !!steps 红黑树的旋转改变红链接的指向
左旋转会将红色的右链接转移到左侧。
1. [左旋前的右结点 _`r`_ 是红色](!focus#199)
2. [右结点 _`r`_ 替代 _`o`_ 成为了新的中间结点](!focus#156,200)
3. [_`o`_ 成为了 _`r`_ 的左子结点，并标记为红色](!focus#153:154)，转换后左结点变成了红色

右旋转会将红色的左链接转移到右侧。

```go !!codes !lines(151:167,197:210) red_black_tree.go
!from ./red_black_tree.go 151:210
```
</Accordion>

// rotateLeft 将 o.right 旋转到 o 的位置，o 变成 o.right 的左子节点
// 同时将 o.right 的红色转移给 o
// rotateRight 将 o.left 旋转到 o 的位置，o 变成 o.left 的右子节点
// 同时将 o.left 的红色转移给 o
// flipColors 将 o 和它的两个子节点的颜色进行翻转
// 将颜色向上或者向下传递
// balance 恢复红黑树的平衡