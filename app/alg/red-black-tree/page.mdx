# 红黑树 Red Black Tree

红黑树（Red-Black Tree）是一种自平衡二叉查找树（BST），它在插入和删除节点时通过重新着色和旋转操作来保持树的平衡，从而确保在最坏的情况下基本的动态集合操作（如插入、删除、查找等）时间复杂度为 $O(\lg n)$。

本篇分析了黑树的 Go 语言实现，旨在帮助读者能熟悉红黑树的性质并独立实现红黑树。

## 左倾红黑树的主要特点：


红黑树模型中结点通过红链（红色链接）连接到父结点，用来模拟 2-3平衡查找树 中的 3-结点，而在代码实现中我们将子结点的 _`color`_ 属性标记为红色。所以，红/黑结点 和 红/黑链接的表述都是同一个意思。

红黑树的黑色链接高度定义为「任意空链接到根结点的简单路径上的黑链接数量」。
左倾红黑树有下面一些特点， 其中一些是为了简化代码实现和定义所作的规定，我们对红黑树构建的必要条件做了 '❗️' 标记。
<Accordion className="h-[750px]">
### !!steps 二叉树 ❗️
红黑树是一棵二叉查找树，满足一切二叉查找树性质。

!focus(50:61) 可以方便的实现如 有序集合、有序字典 等数据结构，并在 $O(\lg n)$ 的时间内完成如（插入、删除、查找等）操作。

右侧代码:
- _go`func(o *node) get(key int) *node`_ 是红黑树根据键查找值的实现，与二叉树查找完全一致。
- _go`func (o *node) put(key, val int) *node`_ 是红黑树插入键值的实现，和二叉树相比，插入值后，多一步平衡操作 _`x.balance()`_。

```go  !!codes !lines(49:62,67:82)  red_black_tree.go 
!from ./red_black_tree.go 49:82
```

```go !!codes !lines(74:81) red_black_tree_test.go
!from ./red_black_tree_test.go 74:81
```
### !!steps 红黑结点 ❗️
每个节点要么是红色，要么是黑色。
和二叉树相比，红黑树结点结构中多一个 _go`color bool`_ 字段，标记结点当前颜色。

```go !!codes  !lines(2:21) red_black_tree.go
!from ./red_black_tree.go 2:21
```

### !!steps 无连续红结点 ❗️
如果一个节点是红色的，那么它的子节点必须是黑色的（即不能有两个连续的红色节点）。

红黑树可以理解为用 红黑结点组成的二叉树 模拟实现 「2-3平衡查找树」 ，将红结点和它的父结点共同组成 3-结点。若出现连续的两个红结点，则出现了4-结点，2-3树 不允许这种情况出现。

```go !!codes !lines(63:73,81:86) red_black_tree_test.go
!from ./red_black_tree_test.go 63:86
```
### !!steps 黑根
树的根节点必须是黑色。
允许根为红并不会破环红黑树的平衡性，但会让性质的定义和代码实现更复杂，如:
- 黑结点高度规定为「任意空结点到根结点的路径上黑结点数量」，这保证了任一黑高路径至少有一半是黑结点。
- 操作结束后，最后一步会强制将根结点改成黑。删除时判断是否需要将根结点标红的逻辑会更简单。

```go !!codes !lines(62:67,82:100) red_black_tree.go
!from ./red_black_tree.go 62:100
```
### !!steps 黑叶子（NIL）
所有的叶子节点（ NIL 节点）都是黑色的。 红黑树将二叉树的叶子结点的 NIL 子结点视为叶子结点，并约定颜色为黑色。

和黑根的约定类似，不将 NIL 结点视为叶子结点并不会破坏红黑树，但会让黑色结点高度定义和代码实现更复杂, 如：
- ru 平衡操作中需要判断 _go`x.left.left.isRed()`_, _go`x.right.left.isRed()`_，如果没有黑叶子约定，需要先判断是否空结点，再对应实现逻辑。


```go !!codes !lines(14:21,196:211) red_black_tree.go
!from ./red_black_tree.go 14:211
```

### !!steps 完美黑平衡 ❗️
任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。

```go !!codes !lines(63:73,87:110) red_black_tree_test.go
!from ./red_black_tree_test.go 63:110
```


### !!steps 左倾
为了方便代码实现，我们规定「红链接均为左链接」，即平衡操作完成后红色结点均为左子结点。

一个 3-结点里，额外的 key 是在左边还是右边，其实是对称的。 所以用红链接表示 3-结点时，会有 两种等价表示：
- 父红 + 左黑（红在左）
- 父黑 + 右红（红在右）

如果不加约束，树的表示就不唯一，代码维护也很麻烦。
约定左倾后，每个 3-结点只有左倾这一种表示方式，插入删除时只需要处理固定的几种情况，可以大幅简化代码实现。

</Accordion>



// rotateLeft 将 o.right 旋转到 o 的位置，o 变成 o.right 的左子节点
// 同时将 o.right 的红色转移给 o
// rotateRight 将 o.left 旋转到 o 的位置，o 变成 o.left 的右子节点
// 同时将 o.left 的红色转移给 o
// flipColors 将 o 和它的两个子节点的颜色进行翻转
// 将颜色向上或者向下传递
// balance 恢复红黑树的平衡