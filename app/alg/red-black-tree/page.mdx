# 红黑树 Red Black Tree

红黑树（Red-Black Tree）是一种自平衡二叉查找树（BST），它在插入和删除节点时通过重新着色和旋转操作来保持树的平衡，从而确保在最坏的情况下基本的动态集合操作（如插入、删除、查找等）时间复杂度为 $O(\lg n)$。

本篇分析了黑树的 Go 语言实现，旨在帮助读者能熟悉红黑树的性质并独立实现红黑树。

## 1. 左倾红黑树的主要特点

_rbt|红黑树`E,A,R,C,H,X,M,P,L`_

红黑树模型中结点通过红链（红色链接）连接到父结点，用来模拟 2-3平衡查找树 中的 3-结点，而在代码实现中我们将子结点的 _`color`_ 属性标记为红色。所以，红/黑结点 和 红/黑链接的表述都是同一个意思。

红黑树的黑色链接高度定义为「任意空链接到根结点的简单路径上的黑链接数量」。
左倾红黑树有下面一些特点， 其中一些是为了简化代码实现和定义所作的规定，我们对红黑树构建的必要条件做了 '❗️' 标记。

<Accordion className="h-[750px]">

### !!steps 二叉树 ❗️
红黑树是一棵二叉查找树，满足一切二叉查找树性质。

[可以方便的实现如 有序集合、有序字典 等数据结构，并在 $O(\lg n)$ 的时间内完成如（插入、删除、查找等）操作](!focus#50,81)。

右侧代码:
- [红黑树根据键查找值的实现与二叉树查找完全一致。](!focus#50,61)
- [红黑树插入键值的实现和二叉树相比，插入后的递归回溯阶段多一步平衡操作。](!focus#68,80:81)


```go  !!codes !lines(49:62,67:82)  red_black_tree.go 
!from ./red_black_tree.go 49:82
```

```go !!codes !lines(64:73,74:81) red_black_tree_test.go
!from ./red_black_tree_test.go 64:81
```
### !!steps 红黑结点 ❗️

[每个节点要么是红色，要么是黑色。](!focus#4:5,15,19)

[和二叉树相比，红黑树结点结构中多一个 _go`color bool`_ 字段，标记结点当前颜色。](!focus#8,11)


```go !!codes  !lines(2:21) red_black_tree.go
!from ./red_black_tree.go 2:21
```
### !!steps 左倾
为了方便代码实现，我们规定「红链接均为左链接」，即[平衡操作完成后红色结点均为左子结点。](!focus#199,205)

一个 3-结点里，额外的 key 是在左边还是右边，其实是对称的。 所以用红链接表示 3-结点时，会有 两种等价表示：
- 父红 + 左黑（红在左）
- 父黑 + 右红（红在右）

如果不加约束，树的表示就不唯一，代码维护也很麻烦。
约定左倾后，每个 3-结点只有左倾这一种表示方式，插入删除时只需要处理固定的几种情况，可以大幅简化代码实现。

```go !!codes !lines(197:211) red_black_tree.go
!from ./red_black_tree.go 197:211
```

### !!steps 黑根
[规定根节点是黑色。](!focus#65,94:96)

允许根为红并不会破环红黑树的平衡性，但会让性质的定义和代码实现更复杂，如:
- 黑结点高度规定为「任意空链接到根结点的简单路径上的黑链接数量」，这保证了任一黑高路径至少有一半是黑结点。
- 操作结束后，最后一步会强制将根结点改成黑。[删除时判断是否需要将根结点标红的逻辑会更简单。](!focus#90:92)

```go !!codes !lines(62:67,82:100) red_black_tree.go
!from ./red_black_tree.go 62:100
```
### !!steps 黑叶子
所有的叶子节点（ NIL 节点）都是黑色的。 红黑树将二叉树的叶子结点的 NIL 子结点视为叶子结点，并约定颜色为黑色。

和黑根的约定类似，不将 NIL 结点视为叶子结点并不会破坏红黑树，但会让黑色结点高度定义和代码实现更复杂, 如：
- [平衡操作中需要判断 _go`x.left.left.isRed()`_, _go`x.right.left.isRed()`_](!focus#202)，如果没有黑叶子约定，需要先判断是否空结点，再对应实现逻辑。
- 删除操作中也有 _go`x.left.left.isRed()`_, _go`x.right.left.isRed()`_ 条件判断。


```go !!codes !lines(14:21,196:211) red_black_tree.go
!from ./red_black_tree.go 14:211
```

### !!steps 完美黑平衡 ❗️
[任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。](!focus#92:97,100:105)

这条性质决定了一棵大小为 $N$ 的红黑树的高度不会超过 $2\lg N$。
简单证明下：
- 左倾红黑树最坏的情况是构成树根到最左边叶子结点的路径是红黑相间的，而树根到最右边叶子结点的路径全是黑的。最右侧结点数量上界 $\lg N$，所以左边路径结点数量上界 $2\lg N$，完成证明。

```go !!codes !lines(63:73,87:110) red_black_tree_test.go
!from ./red_black_tree_test.go 63:110
```
### !!steps 无连续红结点 ❗️
[如果一个节点是红色的，那么它的子节点必须是黑色的（即不能有两个连续的红色节点）。](!focus#69,81,85) 红色结点不连续，才能保证「完美黑高平衡」 是有意义的，从而保证各种操作的时间复杂度都能制在 $O(\lg n)$。

红黑树可以理解为用 红黑结点组成的二叉树 模拟实现 「2-3平衡查找树」 ，将红结点和它的父结点共同组成 3-结点。若出现连续的两个红结点，则出现了4-结点，2-3树 不允许这种情况出现。

```go !!codes !lines(63:73,81:86) red_black_tree_test.go
!from ./red_black_tree_test.go 63:86
```



</Accordion>

## 2. 红黑树的平衡操作可以控制红色的转移

二叉查找树的基础的平衡操作有 「左旋」，「右旋」 和 「颜色翻转」。
通过这三种平衡操作，我们可以在**不破环二叉树**，**不破环红黑树的平衡**的前提下，操作着**红色结点的向着我们预期的方向转移**。

### 2.1 颜色翻转

<Accordion className="h-[450px]">

#### !!steps 红色向上传递
当左右子结点都是红色，且父结点是黑色时，我们执行翻转可以将红色子结点转移到父结点上。也就时将红色向上（树根方向）传递。

<div>
_rbt_serialized|翻转后`p,o,null,l|red,r|red`_
_rbt_serialized|翻转前`p,o|red,null,l,r`_
</div>

```go !!codes !lines(169:174) red_black_tree.go
!from ./red_black_tree.go 169:174
```
#### !!steps 红色向下传递

反过来，当子结点都是黑色，且父结点时红色时，我们执行翻转会将红色链接丛父结点转移到子结点上，也就是将红色向下传递。
<div>
_rbt_serialized|翻转前`p,o|red,null,l,r`_
_rbt_serialized|翻转后`p,o,null,l|red,r|red`_
</div>

```go !!codes !lines(169:174) red_black_tree.go
!from ./red_black_tree.go 169:174
```
</Accordion>

### 2.2 旋转

下面图示是向左旋转和向右旋转，本文中简称 「左旋」 和 「右旋」，

_rbt_serialized|左旋`o,l,r|red,null,null,rl,rr:\to:r,o|red,rr,l,rl`_
<span className="w-20 inline-block"/> _rbt_serialized|右旋`o,l|red,r,ll,lr,null:\to:l,ll,o|red,null,null,lr,r`_

<Accordion className="h-[700px]">

### !!steps 旋转不会破环二叉查找树
[红黑树的左旋和右旋的实现，在其他平衡二叉树左右旋转的基础上，再加上颜色的转移。](!focus#154,163)

旋转前后键的大小关系不变：
- 左旋前后键值大小关系保持 _go`o < rl < r`_
  - 旋转前 _`o.r -> r, r.l -> rl`_
  - [旋转后 _`r.l -> o, o.r -> rl`_](!focus#153)
- 右旋前后键值大小关系保持  _go`l < lr < o`_
  - 旋转前 _`l.r -> lr, o.l -> l`_
  - [旋转后 _go`l.r -> o, o.l -> lr`_](!focus#162)


```go !!codes !lines(151:167) red_black_tree.go
!from ./red_black_tree.go 151:167
```
### !!steps 旋转不会破环「完美黑平衡」

旋转改变了左右子树高度，但旋转前后左右黑色链接高度没变，红黑树仍是完美平衡的。


### !!steps 旋转将红色向左右转移
左旋会将右结点的红色转移到左侧。
1. [左旋前的右结点 _`r`_ 是红色](!focus#199)
2. [右结点 _`r`_ 替代 _`o`_ 成为了新的中间结点](!focus#156,200)
3. [_`o`_ 成为了 _`r`_ 的左子结点，并标记为红色](!focus#153:154)，转换后新子树的左子结点变成了红色

同样，[右旋会将左结点的红色转移到右侧。](!focus#162:163,165,202:203)

```go !!codes !lines(151:167,197:210) red_black_tree.go
!from ./red_black_tree.go 151:210
```
</Accordion>


## 红黑树插入的实现

在了解了 「左旋」，「右旋」 和 「颜色翻转」 之后，我们已经有了操控红点结点的能力。接下来，我们来思考下如何实现红黑树的插入的代码。

<Tree>

### !left
我们以 [二叉树的方式插入结点](!focus#63:64,66,68:79,81) 之后，红黑树 「无连续红结点」 和 「完美黑平衡」 两点性质可能会受到影响。如果我们能保证这两点，插入操作完成后我们得到的仍是一棵红黑树。

完美黑平衡
  - 找到插入位置之后，我们 [插入一个红色的新结点](!focus#70:72)，不影响「完美黑平衡」。
  - 后续的所有操作，我们都只使用之前讨论过的 「翻转颜色」、「左旋」 和「右旋」，也不影响 「完美黑平衡」。

连续红结点
  - 在完成红色新结点的插入后，在插入 _go`put(key, val)`_ 方法递归调用的回溯阶段，对因为新结点插入而出现的连续红色结点进行修复。
  - 思路就是：
    1. 左倾： 为了避免过于复杂的代码分支讨论，我们规定了实现的是左倾红黑树，将右侧红色结点转移到左侧。这个操作也排除了右侧出现红色结点连续的可能。
    2. 左侧红结点连续：

### !right

```go !!codes !lines(63:81,196:210) red_black_tree.go
!from ./red_black_tree.go 63:210
```


```go !!codes !lines(63:81) red_black_tree2.go
!from ./red_black_tree.go 63:81
```

#### !content 示意图
<div className='Flex flex-col'>
<div>
      _rbt_serialized|左旋`o,l,r|red,null,null,rl,rr:\to:r,o|red,rr,l,rl`_
</div>
</div>

</Tree>


// 将颜色向上或者向下传递
// balance 恢复红黑树的平衡